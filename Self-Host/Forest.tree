ui8 _cTOKENTYPE_NONE = 0;
// Literals
ui8 _cTOKENTYPE_INTEGER = 1;
ui8 _cTOKENTYPE_FLOAT = 2;
ui8 _cTOKENTYPE_STRING = 3;
ui8 _cTOKENTYPE_CHAR = 4;
ui8 _cTOKENTYPE_BOOL = 5;
// Operators
ui8 _cTOKENTYPE_MINUS = 6;
ui8 _cTOKENTYPE_PLUS = 7;
ui8 _cTOKENTYPE_MULTIPLY = 8;
ui8 _cTOKENTYPE_POWER_OF = 9;
ui8 _cTOKENTYPE_DIVIDE = 10;
ui8 _cTOKENTYPE_MODULUS = 11;
ui8 _cTOKENTYPE_XOR = 12;
ui8 _cTOKENTYPE_OR = 13;
ui8 _cTOKENTYPE_AND = 14;
ui8 _cTOKENTYPE_NOT = 15;
ui8 _cTOKENTYPE_NEGATE = 16;
ui8 _cTOKENTYPE_LESS_THAN = 17;
ui8 _cTOKENTYPE_SHIFT_LEFT = 18;
ui8 _cTOKENTYPE_GREATER_THAN = 19;
ui8 _cTOKENTYPE_SHIFT_RIGHT = 20;
ui8 _cTOKENTYPE_REFERENCE_OF = 21;
ui8 _cTOKENTYPE_DEREFERENCE = 22;
// Syntax
ui8 _cTOKENTYPE_DOT = 23;
ui8 _cTOKENTYPE_RANGE = 24;
ui8 _cTOKENTYPE_COLON = 25;
ui8 _cTOKENTYPE_PARENTHESIS_OPEN = 26;
ui8 _cTOKENTYPE_PARENTHESIS_CLOSE = 27;
ui8 _cTOKENTYPE_SQUARE_OPEN = 28;
ui8 _cTOKENTYPE_SQUARE_CLOSE = 29;
ui8 _cTOKENTYPE_CURLY_OPEN = 30;
ui8 _cTOKENTYPE_CURLY_CLOSE = 31;
ui8 _cTOKENTYPE_COMMA = 32;
ui8 _cTOKENTYPE_MACRO = 33;
ui8 _cTOKENTYPE_SINGLE_QUOTE = 34;
ui8 _cTOKENTYPE_DOUBLE_QUOTE = 35;
ui8 _cTOKENTYPE_SEMICOLON = 36;
ui8 _cTOKENTYPE_SINGLELINE_COMMENT = 37;
ui8 _cTOKENTYPE_MULTILINE_COMMENT = 38;
ui8 _cTOKENTYPE_NAMESPACE = 39;

ui8 _cTOKENTYPE_ASSIGNMENT = 64; // To be used as a bit flag
ui8 _cTOKENTYPE_EQUALITY = 128;

ui16 _cTOKENTYPE_KEYWORD_IDENTIFIER = 512;
ui16 _cTOKENTYPE_KEYWORD_IF = 513;
ui16 _cTOKENTYPE_KEYWORD_ELSE = 514;
ui16 _cTOKENTYPE_KEYWORD_LOOP = 515;
ui16 _cTOKENTYPE_KEYWORD_BREAK = 516;
ui16 _cTOKENTYPE_KEYWORD_SKIP = 517;
ui16 _cTOKENTYPE_KEYWORD_RETURN = 518;
ui16 _cTOKENTYPE_KEYWORD_STRUCT = 519;
ui16 _cTOKENTYPE_KEYWORD_CLASS = 520;

ui16 _cTOKENTYPE_ESCAPE_STRING = 1024;
ui16 _cTOKENTYPE_ESCAPE_CHAR = 1025;

ui8 _cPARSER_NODETYPE_NONE = 0;
ui8 _cPARSER_NODETYPE_PROGRAMME = 1;
ui8 _cPARSER_NODETYPE_FUNCTION = 2;
ui8 _cPARSER_NODETYPE_PARAM_LIST = 3;
ui8 _cPARSER_NODETYPE_BLOCK = 4;
ui8 _cPARSER_NODETYPE_ELSE_IF = 5;
ui8 _cPARSER_NODETYPE_VARIABLE_DECLARATION = 6;
ui8 _cPARSER_NODETYPE_VARIABLE_DECLARATION_ASSIGNMENT = 7;
ui8 _cPARSER_NODETYPE_VARIABLE_ASSIGNMENT = 8;
ui8 _cPARSER_NODETYPE_FUNCTION_CALL = 9;
ui8 _cPARSER_NODETYPE_EXPRESSION = 10;
ui8 _cPARSER_NODETYPE_IF = 11;
ui8 _cPARSER_NODETYPE_ELSE = 12;
ui8 _cPARSER_NODETYPE_BREAK = 13;
ui8 _cPARSER_NODETYPE_SKIP = 14;
ui8 _cPARSER_NODETYPE_RETURN = 15;
ui8 _cPARSER_NODETYPE_LOOP = 16;
ui8 _cPARSER_NODETYPE_UNTIL = 17;
ui8 _cPARSER_NODETYPE_RANGE = 18;
ui8 _cPARSER_NODETYPE_TYPE = 19;
ui8 _cPARSER_NODETYPE_TOKEN = 20;
ui8 _cPARSER_NODETYPE_PROPERTY = 21;
ui8 _cPARSER_NODETYPE_INDEX = 22;
ui8 _cPARSER_NODETYPE_RANGE_MIN = 23;
ui8 _cPARSER_NODETYPE_RANGE_MAX = 24;
ui8 _cPARSER_NODETYPE_RANGE_STEP = 25;
ui8 _cPARSER_NODETYPE_NAMESPACE = 26;
ui8 _cPARSER_NODETYPE_CLASS = 27;
ui8 _cPARSER_NODETYPE_ARG_LIST = 28;
ui8 _cPARSER_NODETYPE_ARGUMENT = 29;
ui8 _cPARSER_NODETYPE_ASSIGNMENT = 30;

ui8 _cPARSER_TYPETYPE_VOID = 0;
ui8 _cPARSER_TYPETYPE_UI8 = 1;
ui8 _cPARSER_TYPETYPE_UI16 = 2;
ui8 _cPARSER_TYPETYPE_UI32 = 3;
ui8 _cPARSER_TYPETYPE_UI64 = 4;
ui8 _cPARSER_TYPETYPE_I8 = 5;
ui8 _cPARSER_TYPETYPE_I16 = 6;
ui8 _cPARSER_TYPETYPE_I32 = 7;
ui8 _cPARSER_TYPETYPE_I64 = 8;
ui8 _cPARSER_TYPETYPE_F8 = 9;
ui8 _cPARSER_TYPETYPE_F16 = 10;
ui8 _cPARSER_TYPETYPE_F32 = 11;
ui8 _cPARSER_TYPETYPE_F64 = 12;
ui8 _cPARSER_TYPETYPE_BOOL = 13;
ui8 _cPARSER_TYPETYPE_CHAR = 14;
ui8 _cPARSER_TYPETYPE_REF = 15;
ui8 _cPARSER_TYPETYPE_ARRAY = 16;
ui8 _cPARSER_TYPETYPE_STRUCT = 17;
ui8 _cPARSER_TYPETYPE_CLASS = 18;

void memcopy2(ref<ui8> dest, ref<ui8> src, ui64 bytes) {
	loop i, 0..bytes {
		dest[i] = src[i];
	}
}

void memcopy(ref<ui8> destination, ref<ui8> source, ui64 bytes) {
	// First copy over every 8 bytes, and then individual bytes
	ref<ui64> resizedDest = destination;
	ref<ui64> resizedSrc = source;
	ui64 size = bytes / 8;
	loop i, 0..size {
		resizedDest[i] = resizedSrc[i];
	}
	loop i, 0..bytes % 8 {
		destination[(size * 8) + i] = source[i];
	}
}

bool StrEquals(ref<ui8> s1, ref<ui8> s2, ui64 length) {
	loop i, 0..length {
		if s1[i] != s2[i] {
			return false;
		}
	}
	return true;
}

ui16 GetLengthOfCstring(ref<ui8> input) {
	ui32 it = 0;
	loop {
		ui8 byte = input[it];
		if byte != 0 {
			it += 1;
		} else {
			return it;
		}
	}
	return 0;
}

struct Token {
	ui16 type;
	ui32 line;
	ui32 column;
	ref<ui8> file;
	ref<ui8> text;
	ui64 textLength;
}

void PrintToken(ref<Token> token) {
	Token t = @token;
	ui16 lengthOfFile = GetLengthOfCstring(t.file);
	stdout.write("'");
	SYS_WRITE(1, t.text, t.textLength);
	stdout.write("' at ");
	SYS_WRITE(1, t.file, lengthOfFile);
	stdout.write(":");
	ui32 line = t.line;
	stdout.write(line);
	ui32 column = t.column;
	stdout.write(":");
	stdout.writeln(column);
}

class TokenArr {
	ui64 size;
	ui64 count;
	ref<Token> tokens;

	void New(ui64 _size) {
		size = _size;
		tokens = alloc((size * 34) + 34);
		count = 0;
	}

	void AddToken(ref<Token> token) {
		// If count exceeded size, realloc and move
		if (count + 1) == size {
			ui64 s = size * 2;
			ui64 c = count + 1;
			ref<Token> newRef = alloc((s * 34) + 34);
			memcopy2(newRef, tokens, count * 34);
			dealloc(tokens, (size * 34) + 34);
			tokens = newRef;
			size = s;
			count = c;
		} else {
			ui64 c = count;
			memcopy2(tokens + (count * 34), token, 34);
			c += 1;
			count = c;
		}
	}
	ref<Token> At(ui64 index) {
		if index >= count {
			stdout.writeln("TokenArr Index out of Bounds");
			SYS_EXIT(1);
		}
		return tokens + (index * 34);
	}
}

void Tokenise(ref<TokenArr> tokens, ref<ui8> source, ui64 sourceLength, ref<ui8> file) {
	Token currentToken = {1, 1, 0, file, 0, 0};
	ui64 start = 0;
	ui16 currentType = 0;
	ui64 textLength = 0;
	ui32 line = 1;
	loop i, 0..sourceLength {
		start += 1;
		ui8 byte = source[i];
		if (currentType == _cTOKENTYPE_STRING) & (byte != '"') {
			textLength += 1;
			skip;
		} else if (currentType == _cTOKENTYPE_CHAR) & (byte != 39) {
			textLength += 1;
			skip;
		} else if currentType == _cTOKENTYPE_MULTILINE_COMMENT {
			if (byte == '*') & (source[i + 1] == '/') {
				currentToken.type = currentType;
				currentToken.textLength = textLength;
				EndToken(tokens, \currentToken);
				textLength = 0;
				currentType = 0;
				i += 1;
				skip;
			} else {
				textLength += 1;
				skip;
			}
		} else if (currentType == _cTOKENTYPE_SINGLELINE_COMMENT) & (byte != 10) {
			textLength += 1;
			skip;
		}

		if (byte >= '0') & (byte <= '9') {
			if currentType == _cTOKENTYPE_NONE {
				currentType = _cTOKENTYPE_INTEGER;
				currentToken.column = start;
				currentToken.text = source + i;
				textLength = 1;
			} else if currentType <= _cTOKENTYPE_CHAR {
				textLength += 1;
			} else if currentType == _cTOKENTYPE_NONE {
				currentType = _cTOKENTYPE_INTEGER;
				currentToken.column = start;
				currentToken.text = source + i;
				textLength = 1;
			} else if currentType == _cTOKENTYPE_MINUS {
				currentType = _cTOKENTYPE_INTEGER;
				textLength += 1;
			}  else if currentType == _cTOKENTYPE_KEYWORD_IDENTIFIER {
				textLength += 1;
			} else {
				currentToken.type = currentType;
				currentToken.textLength = textLength;
				EndToken(tokens, \currentToken);
				currentType = _cTOKENTYPE_INTEGER;
				currentToken.column = start;
				currentToken.text = source + i;
				textLength = 1;
			}
		} else if byte == '.' { // TODO(#1): Dot with 2 identifiers doesn't get tokenised correctly
			if currentType == _cTOKENTYPE_FLOAT {
				currentToken.type = _cTOKENTYPE_INTEGER;
				currentToken.textLength = textLength - 1;
				EndToken(tokens, \currentToken);
				currentToken.type = _cTOKENTYPE_RANGE;
				currentToken.text = source + (i - 1);
				currentToken.column = start - 1;
				currentToken.textLength = 2;
				EndToken(tokens, \currentToken);
				currentType = _cTOKENTYPE_NONE;
				textLength = 0;
			} else if currentType == _cTOKENTYPE_DOT {
				currentToken.type = _cTOKENTYPE_RANGE;
				currentToken.textLength = textLength + 1;
				EndToken(tokens, \currentToken);
				currentType = _cTOKENTYPE_NONE;
				textLength = 0;
			} else if currentType == _cTOKENTYPE_INTEGER {
				currentType = _cTOKENTYPE_FLOAT;
				textLength += 1;
			} else {
				currentToken.type = currentType;
				currentToken.textLength = textLength;
				EndToken(tokens, \currentToken);
				currentType = _cTOKENTYPE_DOT;
				currentToken.column = start;
				currentToken.text = source + i;
				textLength = 1;
			}
		} else if byte == '/' {
			if currentType == _cTOKENTYPE_DIVIDE {
				currentType = _cTOKENTYPE_SINGLELINE_COMMENT;
				currentToken.text = (source + i) + 1;
				textLength = 0;
				currentToken.column = start + 1;
			} else {
				currentToken.type = currentType;
				currentToken.textLength = textLength;
				EndToken(tokens, \currentToken);
				currentType = _cTOKENTYPE_DIVIDE;
				currentToken.column = start;
				currentToken.text = source + i;
				textLength = 1;
			}
		} else if byte == '-' {
			currentToken.type = currentType;
			currentToken.textLength = textLength;
			EndToken(tokens, \currentToken);
			currentType = _cTOKENTYPE_MINUS;
			currentToken.column = start;
			currentToken.text = source + i;
			textLength = 1;
		} else if byte == '+' {
			currentToken.type = currentType;
			currentToken.textLength = textLength;
			EndToken(tokens, \currentToken);
			currentType = _cTOKENTYPE_PLUS;
			currentToken.column = start;
			currentToken.text = source + i;
			textLength = 1;
		} else if byte == '@' {
			currentToken.type = currentType;
			currentToken.textLength = textLength;
			EndToken(tokens, \currentToken);
			currentType = _cTOKENTYPE_DEREFERENCE;
			currentToken.column = start;
			currentToken.text = source + i;
			textLength = 1;
		} else if byte == '!' {
			currentToken.type = currentType;
			currentToken.textLength = textLength;
			EndToken(tokens, \currentToken);
			currentType = _cTOKENTYPE_NOT;
			currentToken.column = start;
			currentToken.text = source + i;
			textLength = 1;
		} else if byte == '~' {
			currentToken.type = currentType;
			currentToken.textLength = textLength;
			EndToken(tokens, \currentToken);
			currentType = _cTOKENTYPE_NEGATE;
			currentToken.column = start;
			currentToken.text = source + i;
			textLength = 1;
		} else if byte == '(' {
			currentToken.type = currentType;
			currentToken.textLength = textLength;
			EndToken(tokens, \currentToken);
			currentType = _cTOKENTYPE_PARENTHESIS_OPEN;
			currentToken.column = start;
			currentToken.text = source + i;
			textLength = 1;
		} else if byte == ')' {
			currentToken.type = currentType;
			currentToken.textLength = textLength;
			EndToken(tokens, \currentToken);
			currentType = _cTOKENTYPE_PARENTHESIS_CLOSE;
			currentToken.column = start;
			currentToken.text = source + i;
			textLength = 1;
		} else if byte == 123 { // Opening '{'
			currentToken.type = currentType;
			currentToken.textLength = textLength;
			EndToken(tokens, \currentToken);
			currentType = _cTOKENTYPE_CURLY_OPEN;
			currentToken.column = start;
			currentToken.text = source + i;
			textLength = 1;
		} else if byte == '}' {
			currentToken.type = currentType;
			currentToken.textLength = textLength;
			EndToken(tokens, \currentToken);
			currentType = _cTOKENTYPE_CURLY_CLOSE;
			currentToken.column = start;
			currentToken.text = source + i;
			textLength = 1;
		} else if byte == '[' {
			currentToken.type = currentType;
			currentToken.textLength = textLength;
			EndToken(tokens, \currentToken);
			currentType = _cTOKENTYPE_SQUARE_OPEN;
			currentToken.column = start;
			currentToken.text = source + i;
			textLength = 1;
		} else if byte == ']' {
			currentToken.type = currentType;
			currentToken.textLength = textLength;
			EndToken(tokens, \currentToken);
			currentType = _cTOKENTYPE_SQUARE_CLOSE;
			currentToken.column = start;
			currentToken.text = source + i;
			textLength = 1;
		} else if byte == ',' {
			currentToken.type = currentType;
			currentToken.textLength = textLength;
			EndToken(tokens, \currentToken);
			currentType = _cTOKENTYPE_COMMA;
			currentToken.column = start;
			currentToken.text = source + i;
			textLength = 1;
		} else if byte == '^' {
			currentToken.type = currentType;
			currentToken.textLength = textLength;
			EndToken(tokens, \currentToken);
			currentType = _cTOKENTYPE_XOR;
			currentToken.column = start;
			currentToken.text = source + i;
			textLength = 1;
		} else if byte == '#' {
			currentToken.type = currentType;
			currentToken.textLength = textLength;
			EndToken(tokens, \currentToken);
			currentType = _cTOKENTYPE_MACRO;
			currentToken.column = start;
			currentToken.text = source + i;
			textLength = 1;
		} else if byte == '%' {
			currentToken.type = currentType;
			currentToken.textLength = textLength;
			EndToken(tokens, \currentToken);
			currentType = _cTOKENTYPE_MODULUS;
			currentToken.column = start;
			currentToken.text = source + i;
			textLength = 1;
		} else if byte == '=' {
			if ((currentType >= _cTOKENTYPE_MINUS) & (currentType <= _cTOKENTYPE_DEREFERENCE)) | (currentType == _cTOKENTYPE_ASSIGNMENT) {
				currentToken.type = currentType + _cTOKENTYPE_ASSIGNMENT;
				currentToken.textLength = textLength + 1;
				EndToken(tokens, \currentToken);
				currentType = 0;
				textLength = 0;
			} else {
				currentToken.type = currentType;
				currentToken.textLength = textLength;
				EndToken(tokens, \currentToken);
				currentType = _cTOKENTYPE_ASSIGNMENT;
				currentToken.column = start;
				currentToken.text = source + i;
				textLength = 1;
			}
		} else if byte == ':' {
			if currentType == _cTOKENTYPE_COLON {
				currentToken.textLength = textLength + 1;
				currentToken.type = _cTOKENTYPE_NAMESPACE;
				EndToken(tokens, \currentToken);
				currentType = 0;
				textLength = 0;
			} else {
				currentToken.type = currentType;
				currentToken.textLength = textLength;
				EndToken(tokens, \currentToken);
				currentType = _cTOKENTYPE_COLON;
				currentToken.column = start;
				currentToken.text = source + i;
				textLength = 1;
			}
		} else if byte == '|' {
			currentToken.type = currentType;
			currentToken.textLength = textLength;
			EndToken(tokens, \currentToken);
			currentType = _cTOKENTYPE_OR;
			currentToken.column = start;
			currentToken.text = source + i;
			textLength = 1;
		} else if byte == '&' {
			currentToken.type = currentType;
			currentToken.textLength = textLength;
			EndToken(tokens, \currentToken);
			currentType = _cTOKENTYPE_MODULUS;
			currentToken.column = start;
			currentToken.text = source + i;
			textLength = 1;
		} else if byte == '*' {
			if currentType == _cTOKENTYPE_MULTIPLY {
				currentToken.type = _cTOKENTYPE_POWER_OF;
				currentToken.textLength = textLength + 1;
				EndToken(tokens, \currentToken);
				currentType = 0;
				textLength = 0;
			} else if currentType == _cTOKENTYPE_DIVIDE {
				currentType = _cTOKENTYPE_MULTILINE_COMMENT;
				currentToken.text = (source + i) + 1;
				currentToken.column = start + 1;
				textLength = 0;
			} else {
				currentToken.type = currentType;
				currentToken.textLength = textLength;
				EndToken(tokens, \currentToken);
				currentType = _cTOKENTYPE_MULTIPLY;
				currentToken.column = start;
				currentToken.text = source + i;
				textLength = 1;
			}
		} else if byte == '>' {
			if currentType == _cTOKENTYPE_GREATER_THAN {
				textLength += 1;
				currentToken.type = _cTOKENTYPE_SHIFT_RIGHT;
			} else {
				currentToken.type = currentType;
				currentToken.textLength = textLength;
				EndToken(tokens, \currentToken);
				currentType = _cTOKENTYPE_GREATER_THAN;
				currentToken.column = start;
				currentToken.text = source + i;
				textLength = 1;
			}
		} else if byte == '<' {
			if currentType == _cTOKENTYPE_LESS_THAN {
				textLength += 1;
				currentToken.type = _cTOKENTYPE_SHIFT_LEFT;
			} else {
				currentToken.type = currentType;
				currentToken.textLength = textLength;
				EndToken(tokens, \currentToken);
				currentType = _cTOKENTYPE_LESS_THAN;
				currentToken.column = start;
				currentToken.text = source + i;
				textLength = 1;
			}
		} else if byte == '"' {
			if currentType == _cTOKENTYPE_STRING {
				currentToken.type = currentType;
				currentToken.textLength = textLength - 1;
				EndToken(tokens, \currentToken);
				currentType = 0;
				textLength = 0;
			} else {
				currentToken.type = currentType;
				currentToken.textLength = textLength;
				EndToken(tokens, \currentToken);
				currentType = _cTOKENTYPE_STRING;
				currentToken.column = start;
				currentToken.text = (source + i) + 1;
				textLength = 1;
			}
		} else if byte == 39 { // single quote
			if currentType == _cTOKENTYPE_CHAR {
				if textLength > 1 {
					stdout.write("[Tokeniser]: Character literal length longer than 1 character at ");
					ui32 lengthOfFile = GetLengthOfCstring(file);
					SYS_WRITE(1, file, lengthOfFile);
					stdout.write(":");
					stdout.write(line);
					ui32 column = currentToken.column;
					stdout.write(":");
					stdout.writeln(column);
					SYS_EXIT(1);
				}
				currentToken.type = currentType;
				currentToken.textLength = textLength;
				EndToken(tokens, \currentToken);
				currentType = 0;
				textLength = 0;
			} else {
				currentToken.type = currentType;
				currentToken.textLength = textLength;
				EndToken(tokens, \currentToken);
				currentType = _cTOKENTYPE_CHAR;
				currentToken.column = start;
				currentToken.text = (source + i) + 1;
				textLength = 0;
			}
		} else if byte == 92 { // '\'
			if currentType == _cTOKENTYPE_STRING {
				currentType = _cTOKENTYPE_ESCAPE_STRING;
			} else if currentType == _cTOKENTYPE_CHAR {
				currentType = _cTOKENTYPE_ESCAPE_CHAR;
			} else {
				currentToken.type = currentType;
				currentToken.textLength = textLength;
				EndToken(tokens, \currentToken);
				currentType = _cTOKENTYPE_REFERENCE_OF;
				currentToken.column = start;
				currentToken.text = source + i;
				textLength = 1;
			}
		} else if byte == ';' {
			currentToken.type = currentType;
			currentToken.textLength = textLength;
			EndToken(tokens, \currentToken);
			currentType = _cTOKENTYPE_SEMICOLON;
			currentToken.column = start;
			currentToken.text = source + i;
			textLength = 1;
		} else if (byte == 32) | (byte == 9) { // ' ' or '\t'
			if ((currentType == _cTOKENTYPE_SINGLELINE_COMMENT) | (currentType == _cTOKENTYPE_MULTILINE_COMMENT)) | ((currentType == _cTOKENTYPE_STRING) | (currentType == _cTOKENTYPE_CHAR)) {
				textLength += 1;
			} else {
				currentToken.type = currentType;
				currentToken.textLength = textLength;
				EndToken(tokens, \currentToken);
				currentType = 0;
				textLength = 0;
			}
		} else if byte == 10 {
			currentToken.type = currentType;
			currentToken.textLength = textLength;
			EndToken(tokens, \currentToken);
			currentType = 0;
			line += 1;
			currentToken.line = line;
			start = 0;
			textLength = 0;
		} else if ((byte == 'x') | (byte == 'o')) | (((byte >= 'a') & (byte <= 'f')) | ((byte >= 'A') & (byte <= 'F'))) {
			if currentType == _cTOKENTYPE_INTEGER {
				textLength += 1;
			} else if currentType == _cTOKENTYPE_KEYWORD_IDENTIFIER {
				textLength += 1;
			} else {
				currentToken.type = currentType;
				currentToken.textLength = textLength;
				EndToken(tokens, \currentToken);
				currentType = _cTOKENTYPE_KEYWORD_IDENTIFIER;
				currentToken.column = start;
				currentToken.text = source + i;
				textLength = 1;
			}
		} else {
			if currentType != _cTOKENTYPE_KEYWORD_IDENTIFIER {
				currentToken.type = currentType;
				currentToken.textLength = textLength;
				EndToken(tokens, \currentToken);
				currentType = _cTOKENTYPE_KEYWORD_IDENTIFIER;
				currentToken.column = start;
				currentToken.text = source + i;
				textLength = 1;
			} else {
				textLength += 1;
			}
		}
	}
	currentToken.type = currentType;
	currentToken.textLength = textLength;
	EndToken(tokens, \currentToken);
}

void EndToken(ref<TokenArr> tokens, ref<Token> token) {
	Token t = @token;
	if (((t.type) != _cTOKENTYPE_NONE) & ((t.type) != _cTOKENTYPE_SINGLELINE_COMMENT)) & ((t.type) != _cTOKENTYPE_MULTILINE_COMMENT) {
		tokens.AddToken(token);
	}
}

struct Type {
	i32 firstChild;
	i32 nextSibling;
	//i32 extraIndex; // Extra index is to index into the structs/classes array, depending on the TypeType. Structs/Classes will have the name of the struct/class. Name is not necessary for the base types.
	ui16 byteSize;
	i16 align;
	bool signed;
	ui8 typeType; // VOID, UI8, UI16, UI32, UI64, I8, I16, I32, I64, F8, F16, F32, F64, BOOL, CHAR, REF, ARRAY, STRUCT, CLASS
} // (size 14)

class TypeArr {
	ui64 size;
	ui64 count;
	ref<Type> types;

	void New(ui64 _size) {
		size = _size;
		types = alloc((size * 14) + 14);
		count = 0;
	}

	void AddType(ref<Type> type) {
		// If count exceeded size, realloc and move
		if (count + 1) == size {
			ui64 s = size * 2;
			ui64 c = count + 1;
			ref<Type> newRef = alloc((s * 14) + 14);
			memcopy2(newRef, types, count * 14);
			dealloc(types, (size * 14) + 14);
			types = newRef;
			size = s;
			count = c;
		} else {
			ui64 c = count;
			memcopy2(types + (count * 14), type, 14);
			c += 1;
			count = c;
		}
	}

	ui64 GetCount() {
		return count;
	}

	ref<Type> At(ui64 index) {
		return types + (index * 14);
	}
}

class Node {
	i32 firstChild;
	i32 nextSibling;
	ui16 type;
	i32 typeIndex;
	ui64 tokenIndex;

	void SetNS(i32 ns) {
		nextSibling = ns;
	}

	void PrintNode() {
		stdout.write("Node: FC(");
		stdout.write(firstChild);
		stdout.write(") NS(");
		stdout.write(nextSibling);
		stdout.write(") Type(");
		stdout.write(type);
		stdout.write(") TypeIndex(");
		stdout.write(typeIndex);
		stdout.write(") TokenIndex(");
		stdout.write(tokenIndex);
		stdout.write(")");
	}
}// (size 22)

class NodeArr {
	ui64 size;
	ui64 count;
	ref<Node> nodes;

	void New(ui64 _size) {
		size = _size;
		nodes = alloc((size * 22) + 22);
		count = 0;
	}

	void AddNode(ref<Node> node) {
		// If count exceeded size, realloc and move
		if (count + 1) == size {
			ui64 s = size * 2;
			ui64 c = count + 1;
			ref<Node> newRef = alloc((s * 22) + 22);
			memcopy2(newRef, nodes, count * 22);
			dealloc(nodes, (size * 22) + 22);
			nodes = newRef;
			size = s;
			count = c;
		} else {
			ui64 c = count;
			memcopy2(nodes + (count * 22), node, 22);
			c += 1;
			count = c;
		}
	}

	ui64 GetCount() {
		return count;
	}

	void UpdateNS(ui64 index, i32 ns) {
		ref<Node> node = nodes + (index * 22);
		node.SetNS(ns);
	}

	ref<Node> At(ui64 index) {
		return nodes + (index * 22);
	}
}

ui64 GetTypeIndexFromName(ref<TypeArr> typArr, ref<Token> t) {
	Token token = @t;
	bool equals = StrEquals(token.text, "ui8", 3);
	if equals {
		return _cPARSER_TYPETYPE_UI8;
	}
	equals = StrEquals(token.text, "ui16", 4);
	if equals {
		return _cPARSER_TYPETYPE_UI16;
	}
	equals = StrEquals(token.text, "ui32", 4);
	if equals {
		return _cPARSER_TYPETYPE_UI32;
	}
	equals = StrEquals(token.text, "ui64", 4);
	if equals {
		return _cPARSER_TYPETYPE_UI64;
	}
	equals = StrEquals(token.text, "i8", 2);
	if equals {
		return _cPARSER_TYPETYPE_I8;
	}
	equals = StrEquals(token.text, "i16", 3);
	if equals {
		return _cPARSER_TYPETYPE_I16;
	}
	equals = StrEquals(token.text, "i32", 3);
	if equals {
		return _cPARSER_TYPETYPE_I32;
	}
	equals = StrEquals(token.text, "i64", 3);
	if equals {
		return _cPARSER_TYPETYPE_I64;
	}
	equals = StrEquals(token.text, "f8", 2);
	if equals {
		return _cPARSER_TYPETYPE_F8;
	}
	equals = StrEquals(token.text, "f16", 3);
	if equals {
		return _cPARSER_TYPETYPE_F16;
	}
	equals = StrEquals(token.text, "f32", 3);
	if equals {
		return _cPARSER_TYPETYPE_F32;
	}
	equals = StrEquals(token.text, "f64", 3);
	if equals {
		return _cPARSER_TYPETYPE_F64;
	}
	equals = StrEquals(token.text, "bool", 4);
	if equals {
		return _cPARSER_TYPETYPE_BOOL;
	}
	equals = StrEquals(token.text, "char", 4);
	if equals {
		return _cPARSER_TYPETYPE_CHAR;
	}
	equals = StrEquals(token.text, "void", 4);
	if equals {
		return _cPARSER_TYPETYPE_VOID;
	}
	return 15;
}

bool IsTokenSpecifiedType(ref<TokenArr> tArr, ui64 offset, ui16 desiredType) {
	TokenArr tokens = @tArr;
	if offset >= (tokens.count) {
		return false;
	}
	ref<Token> t = tArr.At(offset);
	Token token = @t;
	return (token.type) == desiredType;
}

// Returns how much to increment i by
ui16 ParseType(ref<TokenArr> tArr, ref<TypeArr> typeArr, ui64 offset) {
	TokenArr tokens = @tArr;
	TypeArr typesArr = @typeArr;
	ui64 tokenCount = tokens.count;
	// id [<? ]>?
	ref<Token> t = tArr.At(offset);
	Token token = @t;
	
	ui64 ttype = token.type;
	if (ttype != _cTOKENTYPE_KEYWORD_IDENTIFIER) {
		stdout.write("[Parser]: Expected a type identifier but got ");
		PrintToken(t);
		SYS_EXIT(1);
		return 0;
	}
	ui16 returnVal = 1;
	ui64 childTypeIndex = GetTypeIndexFromName(typeArr, t);
	// if childType == 15, it's not a primitive type
	ref<Type> childTypePtr = typeArr.At(childTypeIndex);
	Type childType = @childTypePtr;


	t = tArr.At(offset + 1);
	Token nextToken = @t;
	ttype = nextToken.type;
	if ttype == _cTOKENTYPE_SQUARE_OPEN {
		bool isNextLiteral = IsTokenSpecifiedType(tArr, offset + 2, _cTOKENTYPE_INTEGER);
		Type typ = {
			childTypeIndex,
			-1,
			childType.byteSize,
			childType.align,
			false,
			_cPARSER_TYPETYPE_ARRAY
		};

		if childTypeIndex >= 15 {
			stdout.writeln("[Parser]: Non-primitive type arrays are not implemented yet");
			SYS_EXIT(1);
		}
		
		if isNextLiteral {
			bool isNextClosingSquare = IsTokenSpecifiedType(tArr, offset + 3, _cTOKENTYPE_SQUARE_CLOSE);
			if !isNextClosingSquare {
				stdout.write("[Parser]: Expected an integer or ']' but got ");
				PrintToken(t);
				SYS_EXIT(1);
			}
			ui64 value = find_ui64_in_string(token.text);
			typ.byteSize = (childType.byteSize) * value;
			returnVal += 3;
		} else {
			bool isNextClosingSquare = IsTokenSpecifiedType(tArr, offset + 2, _cTOKENTYPE_SQUARE_CLOSE);
			if !isNextClosingSquare {
				stdout.write("[Parser]: Expected an integer or ']' but got ");
				PrintToken(t);
				SYS_EXIT(1);
			}
			returnVal += 2;
		}
		typeArr.AddType(\typ);
	}
	else if ttype == _cTOKENTYPE_LESS_THAN {
		bool isRef = StrEquals(token.text, "ref", 3);
		bool isArr = StrEquals(token.text, "array", 5);
		ui64 typeCount = typeArr.GetCount();
		if isRef {
			Type typ = {
				typeCount + 1,
				-1,
				8,
				8,
				false,
				_cPARSER_TYPETYPE_REF
			};
			typeArr.AddType(\typ);
		} else if isArr {
			Type typ = {
				typeCount + 1,
				-1,
				8,
				8,
				false,
				_cPARSER_TYPETYPE_ARRAY
			};
			typeArr.AddType(\typ);
		}
		ui16 depth = ParseType(tArr, typeArr, offset + 2);
		bool hasClosing = IsTokenSpecifiedType(tArr, (offset + 2) + depth, _cTOKENTYPE_GREATER_THAN);
		if !hasClosing {
			stdout.write("[Parser]: Unbalanced angle brackets, expected a '>' to close the ");
			PrintToken(\token);
			stdout.write(" but got ");
			ref<Token> unexpected = tArr.At((offset + 2) + depth);
			PrintToken(unexpected);
			SYS_EXIT(1);
		}
		returnVal += (2 + depth);
	} else {
		return returnVal;
	}
	
	return returnVal;
}

// TODO(#2): Would be nice if we could detect if we are parsing a function call expression and parse it as that instead of just expression
ui64 ParseExpression(ref<TokenArr> tArr, ref<NodeArr> nodeArr, ui64 offset, ui64 max, ui16 endType) {
	ui64 returnValue = 0;
	Node currentNode = { 0, 0, 0, 0, 0 };
	NodeArr nodes = @nodeArr;
	loop i, offset..max {
		bool end = IsTokenSpecifiedType(tArr, i, endType);
		bool isNextEnd = IsTokenSpecifiedType(tArr, i + 1, endType);
		bool isNextMax = (i + 1) == max;
		if end {
			break;
		}
		currentNode.type = _cPARSER_NODETYPE_EXPRESSION;
		currentNode.firstChild = -1;
		if isNextEnd | isNextMax {
			currentNode.nextSibling = -1;
		} else {
			ui64 nodeCount = nodeArr.GetCount();
			currentNode.nextSibling = nodeCount + 1;
		}
		currentNode.typeIndex = -1;
		currentNode.tokenIndex = i;
		nodeArr.AddNode(\currentNode);
		returnValue += 1;
	}
	return returnValue;
}

ui64 ParseFunctionCall(ref<TokenArr> tArr, ref<NodeArr> nodeArr, ui64 offset) {
	TokenArr tokens = @tArr;

	ui64 nodeCount = nodeArr.GetCount();
	Node currentNode = {
		.type = _cPARSER_NODETYPE_FUNCTION_CALL;
		.firstChild = nodeCount + 1;
		.nextSibling = 0;
		.tokenIndex = offset;
		.typeIndex = -1;
	};
	ui64 funcCallNodeState = nodeCount;
	nodeArr.AddNode(\currentNode);
	ui64 toSkip = 0;

	loop j, offset..tokens.count {
		ui16 localToSkip = 0;
		ref<Token> funcCallTokenPtr = tArr.At(j);
		Token funcCallToken = @funcCallTokenPtr;
		if (funcCallToken.type) == _cTOKENTYPE_PARENTHESIS_OPEN {
			break;
		}
		bool equals = IsTokenSpecifiedType(tArr, j + 1, _cTOKENTYPE_PARENTHESIS_OPEN);
		if equals {
			nodeCount = nodeArr.GetCount();
			currentNode.type = _cPARSER_NODETYPE_FUNCTION;
			currentNode.firstChild = nodeCount + 1; // Argument list is child of function
			currentNode.nextSibling = -1;
			currentNode.tokenIndex = j;
			currentNode.typeIndex = -1;
			nodeArr.AddNode(\currentNode);
			toSkip += 1;
			break;
		}
		equals = IsTokenSpecifiedType(tArr, j + 1, _cTOKENTYPE_NAMESPACE);
		if equals {
			nodeCount = nodeArr.GetCount();
			currentNode.type = _cPARSER_NODETYPE_NAMESPACE;
			currentNode.firstChild = -1;
			currentNode.nextSibling = nodeCount + 1;
			currentNode.tokenIndex = j;
			currentNode.typeIndex = -1;
			nodeArr.AddNode(\currentNode);
			localToSkip += 1;
		}
		equals = IsTokenSpecifiedType(tArr, j + 1, _cTOKENTYPE_DOT);
		if equals {
			nodeCount = nodeArr.GetCount();
			currentNode.type = _cPARSER_NODETYPE_CLASS;
			currentNode.firstChild = -1;
			currentNode.nextSibling = nodeCount + 1;
			currentNode.tokenIndex = j;
			currentNode.typeIndex = -1;
			nodeArr.AddNode(\currentNode);
			localToSkip += 1;
		}
		j += localToSkip;
		toSkip += (localToSkip + 1);
	}
	bool assert = IsTokenSpecifiedType(tArr, offset + toSkip, _cTOKENTYPE_PARENTHESIS_OPEN);
	if !assert {
		stdout.writeln("ParseFunctionCall failed assertion - Not opening parenthesis");
		SYS_EXIT(1);
	}

	nodeCount = nodeArr.GetCount();
	currentNode.type = _cPARSER_NODETYPE_ARG_LIST;
	currentNode.firstChild = nodeCount + 1;
	currentNode.nextSibling = -1;
	currentNode.tokenIndex = toSkip + offset;
	currentNode.typeIndex = -1;
	nodeArr.AddNode(\currentNode);
	toSkip += 1; // Skip paren open

	// Following loop is necessary to detect end of argument parsing. We try parsing until a ',' but if there's only one argument it would parse too much.
	// That's why we look up what the matching closing parenthesis is and only parse the expression until that point.
	ui64 matchingParen = 0;
	ui64 parenCount = 1;

	loop j, offset + toSkip..tokens.count {
		// Count opening and closing parentheses, if count gets to 0, we found it
		bool isOpen = IsTokenSpecifiedType(tArr, j, _cTOKENTYPE_PARENTHESIS_OPEN);
		if isOpen {
			parenCount += 1;
		} else {
			bool isClose = IsTokenSpecifiedType(tArr, j, _cTOKENTYPE_PARENTHESIS_CLOSE);
			if isClose {
				parenCount -= 1;
				if parenCount == 0 {
					matchingParen = j;
					break;
				}
			}
		}
	}
	
	bool hasNoArgument = IsTokenSpecifiedType(tArr, offset + toSkip, _cTOKENTYPE_PARENTHESIS_CLOSE);
	if !hasNoArgument {
		// If we have arguments. Function call wasn't 'foo();'
		loop j, offset + toSkip..tokens.count {
			nodeCount = nodeArr.GetCount();
			ui16 localToSkip = 0;

			currentNode.type = _cPARSER_NODETYPE_ARGUMENT;
			currentNode.firstChild = nodeCount + 1;
			currentNode.nextSibling = 0;
			currentNode.tokenIndex = offset + toSkip;
			currentNode.typeIndex = -1;
			ui64 argNodeState = nodeCount;
			nodeArr.AddNode(\currentNode);

			localToSkip += ParseExpression(tArr, nodeArr, j, matchingParen, _cTOKENTYPE_COMMA);
			bool hasNextArgument = (j + localToSkip) != matchingParen;
			if hasNextArgument {
				nodeCount = nodeArr.GetCount();
				nodeArr.UpdateNS(argNodeState, nodeCount);
			} else {
				nodeArr.UpdateNS(argNodeState, -1);
				toSkip += localToSkip;
				break;
			}
			j += localToSkip;
			toSkip += localToSkip;
		}
	}
	assert = IsTokenSpecifiedType(tArr, offset + toSkip, _cTOKENTYPE_PARENTHESIS_CLOSE);
	if !assert {
		stdout.writeln("ParseFunctionCall failed assertion - Not closing parenthesis");
		SYS_EXIT(1);
	}
	toSkip += 1; // skip closing parenthesis, so toSkip is pointing at the semicolon now
	
	bool hasSemi = IsTokenSpecifiedType(tArr, (toSkip + offset), _cTOKENTYPE_SEMICOLON);
	if !hasSemi {
		stdout.write("[Parser]: Expected a ';' to close the statement but got ");
		ref<Token> notSemi = tArr.At(toSkip + offset);
		PrintToken(notSemi);
		SYS_EXIT(1);
	}

	nodeCount = nodeArr.GetCount();
	nodeArr.UpdateNS(funcCallNodeState, nodeCount);
	return toSkip;
}

ui64 ParseVarAssignment(ref<TokenArr> tArr, ref<NodeArr> nodeArr, ui64 offset) {
	TokenArr tokens = @tArr;
	// First, find the '(' or any of the '=' e.g. '+=' '/=' '*=' etc...
	bool isAssignment = false;
	ui64 assignmentIndex = 0;
	loop j, offset+1..tokens.count {
		ref<Token> assignTokenPtr = tArr.At(j);
		Token assignToken = @assignTokenPtr;
		if ((assignToken.type) & _cTOKENTYPE_ASSIGNMENT) == _cTOKENTYPE_ASSIGNMENT {
			isAssignment = true;
			assignmentIndex = j;
			break;
		} else if (assignToken.type) == _cTOKENTYPE_PARENTHESIS_OPEN {
			break;
		}
	}
	if !isAssignment {
		return 0;
	}

	ui64 nodeCount = nodeArr.GetCount();
	Node currentNode = {
		.type = _cPARSER_NODETYPE_VARIABLE_ASSIGNMENT;
		.firstChild = nodeCount + 1;
		.nextSibling = 0;
		.typeIndex = -1;
		.tokenIndex = offset;
	};
	
	ui64 currentNodeState = nodeCount;
	nodeArr.AddNode(\currentNode);
	ui64 toSkip = 1;

	// very.nested.array[39 + 30].property.also.should.be.supported = true
	if assignmentIndex > offset {
		loop j, offset+1..assignmentIndex {
			ui64 localToSkip = 0;
			bool isProperty = IsTokenSpecifiedType(tArr, j, _cTOKENTYPE_DOT);
			bool isArrayIndex = IsTokenSpecifiedType(tArr, j, _cTOKENTYPE_SQUARE_OPEN);
			bool id = IsTokenSpecifiedType(tArr, j+1, _cTOKENTYPE_KEYWORD_IDENTIFIER);
			
			if isProperty {
				bool continuesProp = IsTokenSpecifiedType(tArr, j+2, _cTOKENTYPE_DOT);
				bool continuesIndex = IsTokenSpecifiedType(tArr, j+2, _cTOKENTYPE_SQUARE_OPEN);
				currentNode.type = _cPARSER_NODETYPE_PROPERTY;
				currentNode.firstChild = -1;
				nodeCount = nodeArr.GetCount();
				if continuesProp | continuesIndex {
					currentNode.nextSibling = nodeCount + 1;
				} else {
					currentNode.nextSibling = -1;
				}
				currentNode.typeIndex = -1;
				currentNode.tokenIndex = j + 1;
				nodeArr.AddNode(\currentNode);
				localToSkip += 1;
			} else if isArrayIndex {
				bool continuesProp = IsTokenSpecifiedType(tArr, j+2, _cTOKENTYPE_DOT);
				bool continuesIndex = IsTokenSpecifiedType(tArr, j+2, _cTOKENTYPE_SQUARE_OPEN);
				currentNode.type = _cPARSER_NODETYPE_INDEX;
				nodeCount = nodeArr.GetCount();
				currentNode.firstChild = nodeCount + 1;
				if continuesProp | continuesIndex {
					currentNode.nextSibling = 0;
				} else {
					currentNode.nextSibling = -1;
				}
				currentNode.typeIndex = -1;
				currentNode.tokenIndex = j;
				nodeCount = nodeArr.GetCount();
				ui64 nodeState = nodeCount;
				nodeArr.AddNode(\currentNode);
				localToSkip += ParseExpression(tArr, nodeArr, j + 1, assignmentIndex, _cTOKENTYPE_SQUARE_CLOSE);
				
				if continuesProp | continuesIndex {
					nodeCount = nodeArr.GetCount();
					nodeArr.UpdateNS(nodeState, nodeCount);
				}
			} else {
				break;
			}
			j += localToSkip;
			toSkip += localToSkip;
		}
	}

	toSkip += ParseExpression(tArr, nodeArr, offset + toSkip, tokens.count, _cTOKENTYPE_SEMICOLON);
	nodeCount = nodeArr.GetCount();
	nodeArr.UpdateNS(currentNodeState, nodeCount);
	return toSkip;
}

ui64 ParseVarDeclaration(ref<TokenArr> tArr, ref<NodeArr> nodeArr, ref<TypeArr> typeArr, ui64 offset) {
	TypeArr types = @typeArr;
	TokenArr tokens = @tArr;
	ui64 currType = types.count;
	ui64 toSkip = ParseType(tArr, typeArr, offset);
	ref<Token> token = tArr.At(offset);
	ui64 ttypeIndex = GetTypeIndexFromName(typeArr, token);
	if ttypeIndex == 15 {
		ttypeIndex = currType;
	}
	ref<Token> assignTokenPtr = tArr.At((offset + toSkip) + 1);
	Token assignToken = @assignTokenPtr;

	Node currentNode = {0, 0, 0, 0, 0};
	currentNode.typeIndex = ttypeIndex;
	currentNode.tokenIndex = offset + toSkip;
	ui64 nodeCount = nodeArr.GetCount();
	if ((assignToken.type) & _cTOKENTYPE_ASSIGNMENT) == _cTOKENTYPE_ASSIGNMENT {
		currentNode.type = _cPARSER_NODETYPE_VARIABLE_DECLARATION_ASSIGNMENT;
		currentNode.firstChild = nodeCount + 1;
		currentNode.nextSibling = 0;
		ui64 nodeState = nodeCount;
		nodeArr.AddNode(\currentNode);
		toSkip += 1;

		nodeCount = nodeArr.GetCount();
		currentNode.type = _cPARSER_NODETYPE_ASSIGNMENT;
		currentNode.firstChild = nodeCount + 1;
		currentNode.nextSibling = -1;
		currentNode.typeIndex = -1;
		currentNode.tokenIndex = offset + toSkip;
		nodeArr.AddNode(\currentNode);
		toSkip += 1;

		toSkip += ParseExpression(tArr, nodeArr, offset + toSkip, tokens.count, _cTOKENTYPE_SEMICOLON);
		nodeCount = nodeArr.GetCount();
		nodeArr.UpdateNS(nodeState, nodeCount);
	} else {
		currentNode.type = _cPARSER_NODETYPE_VARIABLE_DECLARATION;
		currentNode.firstChild = -1;
		nodeCount = nodeArr.GetCount();
		currentNode.nextSibling = nodeCount + 1;
		nodeArr.AddNode(\currentNode);
	}
	
	bool hasSemi = IsTokenSpecifiedType(tArr, offset + toSkip, _cTOKENTYPE_SEMICOLON);
	if !hasSemi {
		stdout.write("[Parser]: Expected a ';' to close the statement but got ");
		ref<Token> notSemi = tArr.At(offset + toSkip);
		PrintToken(notSemi);
		SYS_EXIT(1);
	}
	return toSkip;
}

// ParseBody parses until the matching '}'. Its returnValue is the offset from given offset to that matching bracket
ui64 ParseBody(ref<TokenArr> tArr, ref<NodeArr> nodeArr, ref<TypeArr> typeArr, ui64 offset) {
	TokenArr tokens = @tArr;
	TypeArr types = @typeArr;
	bool hasBody = IsTokenSpecifiedType(tArr, offset, _cTOKENTYPE_CURLY_OPEN);
	if !hasBody {
		stdout.write("[Parser]: Expected a '{' for the body but got ");
		ref<Token> bodyToken = tArr.At(offset);
		PrintToken(bodyToken);
		SYS_EXIT(1);
	}
	ui64 nodeCount = nodeArr.GetCount();
	Node currentNode = { nodeCount + 1, 0, _cPARSER_NODETYPE_BLOCK, -1, offset };
	ui64 bodyNodeState = nodeCount;
	ui64 lastStatementState = nodeCount;
	nodeArr.AddNode(\currentNode);
	ui64 returnVal = 1;

	bool hasElse = false;
	loop i, offset + 1..tokens.count {
		ref<Token> nextTokenPtr = tArr.At(i);
		Token nextToken = @nextTokenPtr;
		currentNode.tokenIndex = i;
		ui64 toSkip = 0;
		if hasElse {
			if (nextToken.type) == _cTOKENTYPE_CURLY_OPEN {
				hasElse = false;
				currentNode.type = _cPARSER_NODETYPE_ELSE;
				nodeCount = nodeArr.GetCount();
				currentNode.firstChild = nodeCount + 1;
				currentNode.nextSibling = 0;
				currentNode.typeIndex = -1;
				currentNode.tokenIndex = i - 1;
				ui64 nodeState = nodeCount;
				lastStatementState = nodeCount;
				nodeArr.AddNode(\currentNode);
				toSkip += ParseBody(tArr, nodeArr, typeArr, i);
				nodeCount = nodeArr.GetCount();
				nodeArr.UpdateNS(nodeState, nodeCount);
				
				i += toSkip;
				returnVal += toSkip;
				skip;
			}
			bool isIf = StrEquals(nextToken.text, "if", 2);
			if !isIf {
				stdout.write("[Parser]: Expected a '{' or 'if' after 'else' but got ");
				PrintToken(nextTokenPtr);
				SYS_EXIT(1);
			}
		}

		// Scoped blocks
		if (nextToken.type) == _cTOKENTYPE_CURLY_OPEN {
			toSkip += ParseBody(tArr, nodeArr, typeArr, i);
			i += toSkip;
			returnVal += toSkip;
			skip;
		}

		if (nextToken.type) == _cTOKENTYPE_CURLY_CLOSE {
			nodeArr.UpdateNS(lastStatementState, -1);
			break;
		}
		
		bool equals = StrEquals(nextToken.text, "return", 6);
		if equals {
			currentNode.type = _cPARSER_NODETYPE_RETURN;
			nodeCount = nodeArr.GetCount();
			currentNode.firstChild = nodeCount + 1;
			currentNode.nextSibling = 0;
			currentNode.typeIndex = -1;
			currentNode.tokenIndex = i;
			ui64 nodeState = nodeCount;
			lastStatementState = nodeCount;
			nodeArr.AddNode(\currentNode);
			toSkip += 1;

			toSkip += ParseExpression(tArr, nodeArr, i + toSkip, tokens.count, _cTOKENTYPE_SEMICOLON);
			bool hasSemi = IsTokenSpecifiedType(tArr, i + toSkip, _cTOKENTYPE_SEMICOLON);
			if !hasSemi {
				stdout.write("[Parser]: Expected a ';' to close the statement but got ");
				stdout.writeln("Return failed");
				ref<Token> notSemi = tArr.At(i + toSkip);
				PrintToken(notSemi);
				SYS_EXIT(1);
			}
			nodeCount = nodeArr.GetCount();
			nodeArr.UpdateNS(nodeState, nodeCount);
			i += toSkip;
			returnVal += (toSkip + 1);
			skip;
		}

		equals = StrEquals(nextToken.text, "break", 5);
		if equals {
			currentNode.type = _cPARSER_NODETYPE_BREAK;
			currentNode.firstChild = -1;
			currentNode.nextSibling = 0;
			currentNode.typeIndex = -1;
			currentNode.tokenIndex = i;
			nodeCount = nodeArr.GetCount();
			ui64 nodeState = nodeCount;
			lastStatementState = nodeCount;
			nodeArr.AddNode(\currentNode);
			toSkip += 1;
			bool hasSemi = IsTokenSpecifiedType(tArr, i + toSkip, _cTOKENTYPE_SEMICOLON);
			if !hasSemi {
				stdout.write("[Parser]: Expected a ';' to close the statement but got ");
				ref<Token> notSemi = tArr.At(i + toSkip);
				PrintToken(notSemi);
				SYS_EXIT(1);
			} else {
				toSkip += 1;
			}
			nodeCount = nodeArr.GetCount();
			nodeArr.UpdateNS(nodeState, nodeCount);
			i += toSkip;
			returnVal += toSkip;
			skip;
		}
		
		equals = StrEquals(nextToken.text, "skip", 4);
		if equals {
			currentNode.type = _cPARSER_NODETYPE_SKIP;
			currentNode.firstChild = -1;
			currentNode.nextSibling = 0;
			currentNode.typeIndex = -1;
			currentNode.tokenIndex = i;
			nodeCount = nodeArr.GetCount();
			ui64 nodeState = nodeCount;
			lastStatementState = nodeCount;
			nodeArr.AddNode(\currentNode);
			toSkip += 1;
			bool hasSemi = IsTokenSpecifiedType(tArr, i + toSkip, _cTOKENTYPE_SEMICOLON);
			if !hasSemi {
				stdout.write("[Parser]: Expected a ';' to close the statement but got ");
				ref<Token> notSemi = tArr.At(i + toSkip);
				PrintToken(notSemi);
				SYS_EXIT(1);
			} else {
				toSkip += 1;
			}
			nodeCount = nodeArr.GetCount();
			nodeArr.UpdateNS(nodeState, nodeCount);
			i += toSkip;
			returnVal += toSkip;
			skip;
		}
		
		equals = StrEquals(nextToken.text, "if", 2);
		if equals {
			if hasElse {
				currentNode.type = _cPARSER_NODETYPE_ELSE_IF;
				hasElse = false;
			} else {
				currentNode.type = _cPARSER_NODETYPE_IF;
			}
			nodeCount = nodeArr.GetCount();
			currentNode.firstChild = nodeCount + 1;
			currentNode.nextSibling = 0;
			currentNode.typeIndex = -1;
			currentNode.tokenIndex = i;
			ui64 nodeState = nodeCount;
			lastStatementState = nodeCount;
			nodeArr.AddNode(\currentNode);
			toSkip += 1;

			toSkip += ParseExpression(tArr, nodeArr, i + 1, tokens.count, _cTOKENTYPE_CURLY_OPEN);
			
			if toSkip == 1 {
				stdout.write("[Parser]: Expected an expression for the ");
				PrintToken(nextTokenPtr);
				SYS_EXIT(1);
			}
			toSkip += ParseBody(tArr, nodeArr, typeArr, i + toSkip);
			nodeCount = nodeArr.GetCount();
			nodeArr.UpdateNS(nodeState, nodeCount);
			i += toSkip;
			returnVal += toSkip;
			skip;
		}
		equals = StrEquals(nextToken.text, "else", 4);
		if equals {
			hasElse = true;
			// Rest of code is handled at start loop or if
		}

		equals = StrEquals(nextToken.text, "loop", 4);
		if equals {
			// Parse unconditional loop
			currentNode.type = _cPARSER_NODETYPE_LOOP;
			nodeCount = nodeArr.GetCount();
			currentNode.firstChild = nodeCount + 1;
			currentNode.nextSibling = 0;
			currentNode.typeIndex = -1;
			currentNode.tokenIndex = i;
			ui64 loopNodeState = nodeCount;
			lastStatementState = nodeCount;
			nodeArr.AddNode(\currentNode);
			toSkip += 1;
			
			bool isSimpleLoop = IsTokenSpecifiedType(tArr, i + 1, _cTOKENTYPE_CURLY_OPEN);
			if isSimpleLoop {
				toSkip += ParseBody(tArr, nodeArr, typeArr, i + 1);
			} else {
				bool hasVariable = IsTokenSpecifiedType(tArr, i + 1, _cTOKENTYPE_KEYWORD_IDENTIFIER);
				if !hasVariable {
					stdout.write("[Parser]: Expected a variable identifier for the ");
					PrintToken(nextTokenPtr);
					SYS_EXIT(1);
				}
				nodeCount = nodeArr.GetCount();
				currentNode.type = _cPARSER_NODETYPE_VARIABLE_DECLARATION;
				currentNode.firstChild = -1;
				currentNode.nextSibling = nodeCount + 1;
				currentNode.typeIndex = 0;
				currentNode.tokenIndex = i + 1;
				nodeArr.AddNode(\currentNode);
				toSkip += 1;
				
				bool hasStep = IsTokenSpecifiedType(tArr, i + 2, _cTOKENTYPE_COLON);
				
				if hasStep {
					nodeCount = nodeArr.GetCount();
					currentNode.type = _cPARSER_NODETYPE_RANGE_STEP;
					currentNode.firstChild = nodeCount + 1;
					currentNode.nextSibling = 0;
					currentNode.typeIndex = -1;
					currentNode.tokenIndex = i + 2;
					ui64 stepNodeState = nodeCount;
					nodeArr.AddNode(\currentNode);
					toSkip += 1;

					toSkip += ParseExpression(tArr, nodeArr, i + 2, tokens.count, _cTOKENTYPE_COMMA);
					nodeCount = nodeArr.GetCount()
					nodeArr.UpdateNS(stepNodeState, nodeCount);
				}
				toSkip += 1; // Skip comma

				nodeCount = nodeArr.GetCount();
				currentNode.type = _cPARSER_NODETYPE_RANGE_MIN;
				currentNode.firstChild = nodeCount + 1;
				currentNode.nextSibling = 0;
				currentNode.typeIndex = -1;
				currentNode.tokenIndex = i + toSkip;
				ui64 rangeMinNodeState = nodeCount;
				nodeArr.AddNode(\currentNode);
				toSkip += ParseExpression(tArr, nodeArr, i + toSkip, tokens.count, _cTOKENTYPE_RANGE);
				nodeCount = nodeArr.GetCount();
				nodeArr.UpdateNS(rangeMinNodeState, nodeCount);
				toSkip += 1; // Skip range
				
				currentNode.type = _cPARSER_NODETYPE_RANGE_MAX;
				currentNode.firstChild = nodeCount + 1;
				currentNode.nextSibling = 0;
				currentNode.typeIndex = -1;
				currentNode.tokenIndex = i + toSkip;
				nodeCount = nodeArr.GetCount();
				nodeArr.AddNode(\currentNode);
				ui64 rangeMaxNodeState = nodeCount;
				toSkip += ParseExpression(tArr, nodeArr, i + toSkip, tokens.count, _cTOKENTYPE_CURLY_OPEN);
				nodeCount = nodeArr.GetCount();
				nodeArr.UpdateNS(rangeMaxNodeState, nodeCount);

				toSkip += ParseBody(tArr, nodeArr, typeArr, i + toSkip);
			}
			nodeCount = nodeArr.GetCount();
			nodeArr.UpdateNS(loopNodeState, nodeCount);
			i += toSkip;
			returnVal += toSkip;
			skip;
		}
		equals = StrEquals(nextToken.text, "until", 5);
		if equals {
			nodeCount = nodeArr.GetCount();
			currentNode.type = _cPARSER_NODETYPE_UNTIL;
			currentNode.firstChild = nodeCount + 1;
			currentNode.nextSibling = 0;
			currentNode.typeIndex = -1;
			currentNode.tokenIndex = i;
			ui64 nodeState = nodeCount;
			lastStatementState = nodeCount;
			nodeArr.AddNode(\currentNode);
			toSkip += 1;

			toSkip += ParseExpression(tArr, nodeArr, i + 1, tokens.count, _cTOKENTYPE_CURLY_OPEN);
			toSkip += ParseBody(tArr, nodeArr, typeArr, i + toSkip);
			nodeCount = nodeArr.GetCount();
			nodeArr.UpdateNS(nodeState, nodeCount);
			i += toSkip;
			returnVal += toSkip;
			skip;
		}
		
		bool isIdentifier = IsTokenSpecifiedType(tArr, i, _cTOKENTYPE_KEYWORD_IDENTIFIER);
		bool hasSecondIdent = IsTokenSpecifiedType(tArr, i + 1, _cTOKENTYPE_KEYWORD_IDENTIFIER);
		bool isGeneric = IsTokenSpecifiedType(tArr, i + 1, _cTOKENTYPE_LESS_THAN);
		bool isArray = IsTokenSpecifiedType(tArr, i + 1, _cTOKENTYPE_SQUARE_OPEN);
		bool isArrayType = false;

		if isArray {
			loop j, i + 2..tokens.count {
				bool closing = IsTokenSpecifiedType(tArr, j, _cTOKENTYPE_SQUARE_CLOSE);
				bool ident = IsTokenSpecifiedType(tArr, j + 1, _cTOKENTYPE_KEYWORD_IDENTIFIER);
				if closing & ident {
					isArrayType = true;
					break;
				}
			}
		}

		if isIdentifier {
			if (hasSecondIdent | isGeneric) | isArrayType {
				// We are doing var declaration
				nodeCount = nodeArr.GetCount();
				lastStatementState = nodeCount;
				toSkip += ParseVarDeclaration(tArr, nodeArr, typeArr, i);
			} else {
				nodeCount = nodeArr.GetCount();
				lastStatementState = nodeCount;
				ui64 isAssignment = ParseVarAssignment(tArr, nodeArr, i);

				if isAssignment != 0 {
					toSkip += isAssignment;
				} else {
					toSkip += ParseFunctionCall(tArr, nodeArr, i);
				}
			}
		}

		i += toSkip;
		returnVal += toSkip;
		returnVal += 1;
	}
	nodeCount = nodeArr.GetCount();
	nodeArr.UpdateNS(bodyNodeState, nodeCount);
	return returnVal;
}

ui64 ParseFunction(ref<TokenArr> tArr, ref<NodeArr> nodeArr, ref<TypeArr> typeArr, ui64 offset, i32 typeIndex) {
	TokenArr tokens = @tArr;
	TypeArr types = @typeArr;
	ui64 nodeCount = nodeArr.GetCount();
	Node currentNode = { nodeCount + 1, 0, _cPARSER_NODETYPE_FUNCTION, typeIndex, offset };
	bool isSyntaxCorrect = IsTokenSpecifiedType(tArr, offset + 1, _cTOKENTYPE_PARENTHESIS_OPEN);
	if !isSyntaxCorrect {
		ref<Token> t = tArr.At(offset + 1);
		// This never happens as we only call this function when we have detected (
		stdout.write("[Parser]: Expected '(' for function definition but got ");
		PrintToken(t);
		SYS_EXIT(1);
	}
	ui64 nodeState = nodeCount;
	nodeArr.AddNode(\currentNode);
	ui64 returnVal = 1;

	bool hasNoParameters = IsTokenSpecifiedType(tArr, offset + 2, _cTOKENTYPE_PARENTHESIS_CLOSE);
	if !hasNoParameters {
		nodeCount = nodeArr.GetCount();
		currentNode.firstChild = nodeCount + 1;
		currentNode.nextSibling = 0;
		currentNode.type = _cPARSER_NODETYPE_PARAM_LIST;
		currentNode.typeIndex = -1;
		currentNode.tokenIndex = offset + 1;
		ui64 paramNodeState = nodeCount;
		nodeArr.AddNode(\currentNode);

		// Parse param list... type name, type name, etc...
		loop i, offset + 2..tokens.count {
			ui64 typeCount = typeArr.GetCount();
			ui16 toIncrease = ParseType(tArr, typeArr, i);
			ref<Token> token = tArr.At(i);
			ui64 typIndex = GetTypeIndexFromName(typeArr, token);
			if typIndex == 15 {
				typIndex = typeCount;
			}

			i += toIncrease;
			currentNode.firstChild = -1;
			bool hasComma = IsTokenSpecifiedType(tArr, i + 1, _cTOKENTYPE_COMMA);
			nodeCount = nodeArr.GetCount();
			if hasComma {
				currentNode.nextSibling = nodeCount + 1;
			} else {
				currentNode.nextSibling = -1;
			}
			currentNode.type = _cPARSER_NODETYPE_VARIABLE_DECLARATION;
			currentNode.typeIndex = typIndex;
			currentNode.tokenIndex = i;
			nodeArr.AddNode(\currentNode);
			bool hasClosing = IsTokenSpecifiedType(tArr, i + 1, _cTOKENTYPE_PARENTHESIS_CLOSE);
			if hasClosing {
				returnVal += i;
				break;
			}

			if ((!hasComma) & (!hasClosing)) {
				stdout.write("[Parser]: Expected a ',' or ')' inside the parameter list of function definition ");
				ref<Token> functionToken = tArr.At(offset);
				PrintToken(functionToken);
				SYS_EXIT(1);
			}
		}
		nodeCount = nodeArr.GetCount();
		nodeArr.UpdateNS(paramNodeState, nodeCount);
	} else {
		returnVal += 1;
	}

	bool hasBody = IsTokenSpecifiedType(tArr, offset + returnVal, _cTOKENTYPE_CURLY_OPEN);
	if !hasBody {
		stdout.write("[Parser]: Expected a '{' for the body of function definition but got ");
		ref<Token> bodyToken = tArr.At(offset + returnVal);
		PrintToken(bodyToken);
		SYS_EXIT(1);
	}
	returnVal += (ParseBody(tArr, nodeArr, typeArr, offset + returnVal) + 1);
	nodeCount = nodeArr.GetCount();
	nodeArr.UpdateNS(nodeState, nodeCount);

	return returnVal;
}

void Parse(ref<TokenArr> tArr, ref<NodeArr> nodes, ref<TypeArr> typeArr) {
	TokenArr tokens = @tArr;
	TypeArr types = @typeArr;
	Node currentNode = {1, -1, 1, -1, 0};
	nodes.AddNode(\currentNode);
	ui64 tokenCount = (tokens.count);

	loop i, 0..tokenCount {
		ref<Token> token = tArr.At(i);
		Token t = @token;
		ui64 ttype = t.type;

		if ttype == _cTOKENTYPE_MACRO {
			stdout.writeln("[Parser]: Parsing macros is not supported yet");
			SYS_EXIT(1);
		}

		if ttype != _cTOKENTYPE_KEYWORD_IDENTIFIER {
			stdout.write("[Parser]: Unexpected token type, expected identifier but got ");
			PrintToken(token);
			SYS_EXIT(1);
		}

		bool isStruct = StrEquals(t.text, "struct", 6);
		bool isClass = StrEquals(t.text, "class", 5);
		bool isAligned = StrEquals(t.text, "aligned", 7);
		if (isStruct || isClass) || isAligned {
			stdout.writeln("[Parser]: Parsing structs/classes is not supported yet");
			SYS_EXIT(1);
		}

		ui64 currType = types.count;
		ui16 toIncrease = ParseType(tArr, typeArr, i);
		ui64 typeIndex = GetTypeIndexFromName(typeArr, token);
		if typeIndex == 15 {
			typeIndex = currType;
		}
		i += toIncrease;
		bool isFunction = IsTokenSpecifiedType(tArr, i + 1, _cTOKENTYPE_PARENTHESIS_OPEN);
		if isFunction {
			toIncrease = ParseFunction(tArr, nodes, typeArr, i, typeIndex);
			i += toIncrease;
		}
	}
}

void SetupTypeArr(ref<TypeArr> typeArr) {
	Type ttype = {
		-1,
		-1,
		0,
		0,
		false,
		0
	}; // void
	typeArr.AddType(\ttype);
	ttype.byteSize = 1;
	ttype.align = 1;
	ttype.typeType = 1; // UI8
	typeArr.AddType(\ttype);
	ttype.byteSize = 2;
	ttype.align = 2;
	ttype.typeType = 2; // UI16
	typeArr.AddType(\ttype);
	ttype.byteSize = 4;
	ttype.align = 4;
	ttype.typeType = 3; // UI32
	typeArr.AddType(\ttype);
	ttype.byteSize = 8;
	ttype.align = 8;
	ttype.typeType = 4; // UI64
	typeArr.AddType(\ttype);
	ttype.signed = true;
	ttype.byteSize = 1;
	ttype.align = 1;
	ttype.typeType = 5; // I8
	typeArr.AddType(\ttype);
	ttype.byteSize = 2;
	ttype.align = 2;
	ttype.typeType = 6; // I16
	typeArr.AddType(\ttype);
	ttype.byteSize = 4;
	ttype.align = 4;
	ttype.typeType = 7; // I32
	typeArr.AddType(\ttype);
	ttype.byteSize = 8;
	ttype.align = 8;
	ttype.typeType = 8; // I64
	typeArr.AddType(\ttype);
	ttype.byteSize = 1;
	ttype.align = 1;
	ttype.typeType = 9; // F8
	typeArr.AddType(\ttype);
	ttype.byteSize = 2;
	ttype.align = 2;
	ttype.typeType = 10; // F16
	typeArr.AddType(\ttype);
	ttype.byteSize = 4;
	ttype.align = 4;
	ttype.typeType = 11; // F32
	typeArr.AddType(\ttype);
	ttype.byteSize = 8;
	ttype.align = 8;
	ttype.typeType = 12; // F64
	typeArr.AddType(\ttype);
	ttype.byteSize = 1;
	ttype.align = 1;
	ttype.typeType = 13; // BOOL
	typeArr.AddType(\ttype);
	ttype.byteSize = 4;
	ttype.align = 4;
	ttype.typeType = 14; // CHAR
	typeArr.AddType(\ttype);
}

ui8 main(cstring[] argv) {
	TokenArr tokens = {0, 0, 0};
	tokens.New(1024);
	i32 fd = SYS_OPEN(argv[1], 0, 0);
	if (fd < 0) {
		stdout.writeln("Could not open file");
		return -1;
	}
	ui64 fileSize = SYS_LSEEK(fd, 0, 2);
	SYS_LSEEK(fd, 0, 0);
	ref<ui8> source = alloc(fileSize);

	ui64 sizeRead = SYS_READ(fd, source, fileSize);
	if (sizeRead == 0) {
		stdout.writeln("Could not read from file");
		return -1;
	}
	Tokenise(\tokens, source, sizeRead, argv[1]);
	ui32 lengthOfFile = GetLengthOfCstring(argv[1]);
	ui64 tokenCount = tokens.count;
	/*loop i, 0..tokenCount {
		ref<Token> tok = tokens.At(i);
		Token t = @tok;
		stdout.write("(");
		stdout.write(i);
		stdout.write(") ");
		stdout.write("'");
		SYS_WRITE(1, t.text, t.textLength);
		stdout.write("' at ");
		SYS_WRITE(1, t.file, lengthOfFile);
		stdout.write(":");
		ui32 line = t.line;
		stdout.write(line);
		ui32 column = t.column;
		stdout.write(":");
		stdout.writeln(column);
	}*/
	NodeArr nodes = {0, 0, 0};
	nodes.New(tokenCount);
	TypeArr types = {0, 0, 0};
	types.New(256);
	SetupTypeArr(\types);
	Parse(\tokens, \nodes, \types);

	ui64 nodeCount = nodes.count;
	stdout.writeln("graph \"\"");
	stdout.writeln(" {");
	stdout.writeln("subgraph nodes\n{");
	stdout.writeln("n0 [label=\"*Programme*\"]; \nn0 -- n1 ;");
	loop i, 1..nodeCount {
		ref<Node> n = nodes.At(i);
		Node node = @n;
		stdout.write("n");
		stdout.write(i);
		stdout.write(" [label=\"");
		stdout.write(i);
		stdout.write(". ");
		if ((node.type) == _cPARSER_NODETYPE_ARGUMENT) {
			stdout.write("*Argument*");
		} else if (node.type) == _cPARSER_NODETYPE_FUNCTION_CALL {
			stdout.write("*Function Call*");
		} else if (node.type) == _cPARSER_NODETYPE_ARG_LIST {
			stdout.write("*Arguments*");
		} else if (node.type) == _cPARSER_NODETYPE_BLOCK {
			stdout.write("*Block*");
		} else {
			ref<Token> tok = tokens.At(node.tokenIndex);
			Token t = @tok;
			SYS_WRITE(1, t.text, t.textLength);
		}
		stdout.write("\" tooltip=\"");
		n.PrintNode();
		stdout.writeln("\"] ;");

		if ((node.firstChild) != -1) & ((node.firstChild) != nodeCount) {
			stdout.write("n");
			stdout.write(i);
			stdout.write(" -- ");
			stdout.write("n");
			i32 firstChild = node.firstChild;
			stdout.write(firstChild);
			stdout.writeln(" [label = \"FC\" color = darkgreen];");
		}
		if ((node.nextSibling) != -1) & ((node.nextSibling) != nodeCount) {
			stdout.write("n");
			stdout.write(i);
			stdout.write(" -- ");
			stdout.write("n");
			i32 nextSibling = node.nextSibling;
			stdout.write(nextSibling);
			stdout.writeln(" [label = \"NS\" color = blue];");
		}
		
	}
	stdout.writeln("}");
	stdout.writeln("}");
	return 0;
}
